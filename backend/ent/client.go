// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/tanapon395/playlist-video/ent/migrate"

	"github.com/tanapon395/playlist-video/ent/adminrepair"
	"github.com/tanapon395/playlist-video/ent/brand"
	"github.com/tanapon395/playlist-video/ent/customer"
	"github.com/tanapon395/playlist-video/ent/department"
	"github.com/tanapon395/playlist-video/ent/fix"
	"github.com/tanapon395/playlist-video/ent/fixcomtype"
	"github.com/tanapon395/playlist-video/ent/gender"
	"github.com/tanapon395/playlist-video/ent/paymenttype"
	"github.com/tanapon395/playlist-video/ent/personal"
	"github.com/tanapon395/playlist-video/ent/product"
	"github.com/tanapon395/playlist-video/ent/receipt"
	"github.com/tanapon395/playlist-video/ent/title"
	"github.com/tanapon395/playlist-video/ent/typeproduct"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Adminrepair is the client for interacting with the Adminrepair builders.
	Adminrepair *AdminrepairClient
	// Brand is the client for interacting with the Brand builders.
	Brand *BrandClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// Department is the client for interacting with the Department builders.
	Department *DepartmentClient
	// Fix is the client for interacting with the Fix builders.
	Fix *FixClient
	// Fixcomtype is the client for interacting with the Fixcomtype builders.
	Fixcomtype *FixcomtypeClient
	// Gender is the client for interacting with the Gender builders.
	Gender *GenderClient
	// PaymentType is the client for interacting with the PaymentType builders.
	PaymentType *PaymentTypeClient
	// Personal is the client for interacting with the Personal builders.
	Personal *PersonalClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// Receipt is the client for interacting with the Receipt builders.
	Receipt *ReceiptClient
	// Title is the client for interacting with the Title builders.
	Title *TitleClient
	// Typeproduct is the client for interacting with the Typeproduct builders.
	Typeproduct *TypeproductClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Adminrepair = NewAdminrepairClient(c.config)
	c.Brand = NewBrandClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.Department = NewDepartmentClient(c.config)
	c.Fix = NewFixClient(c.config)
	c.Fixcomtype = NewFixcomtypeClient(c.config)
	c.Gender = NewGenderClient(c.config)
	c.PaymentType = NewPaymentTypeClient(c.config)
	c.Personal = NewPersonalClient(c.config)
	c.Product = NewProductClient(c.config)
	c.Receipt = NewReceiptClient(c.config)
	c.Title = NewTitleClient(c.config)
	c.Typeproduct = NewTypeproductClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Adminrepair: NewAdminrepairClient(cfg),
		Brand:       NewBrandClient(cfg),
		Customer:    NewCustomerClient(cfg),
		Department:  NewDepartmentClient(cfg),
		Fix:         NewFixClient(cfg),
		Fixcomtype:  NewFixcomtypeClient(cfg),
		Gender:      NewGenderClient(cfg),
		PaymentType: NewPaymentTypeClient(cfg),
		Personal:    NewPersonalClient(cfg),
		Product:     NewProductClient(cfg),
		Receipt:     NewReceiptClient(cfg),
		Title:       NewTitleClient(cfg),
		Typeproduct: NewTypeproductClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:      cfg,
		Adminrepair: NewAdminrepairClient(cfg),
		Brand:       NewBrandClient(cfg),
		Customer:    NewCustomerClient(cfg),
		Department:  NewDepartmentClient(cfg),
		Fix:         NewFixClient(cfg),
		Fixcomtype:  NewFixcomtypeClient(cfg),
		Gender:      NewGenderClient(cfg),
		PaymentType: NewPaymentTypeClient(cfg),
		Personal:    NewPersonalClient(cfg),
		Product:     NewProductClient(cfg),
		Receipt:     NewReceiptClient(cfg),
		Title:       NewTitleClient(cfg),
		Typeproduct: NewTypeproductClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Adminrepair.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Adminrepair.Use(hooks...)
	c.Brand.Use(hooks...)
	c.Customer.Use(hooks...)
	c.Department.Use(hooks...)
	c.Fix.Use(hooks...)
	c.Fixcomtype.Use(hooks...)
	c.Gender.Use(hooks...)
	c.PaymentType.Use(hooks...)
	c.Personal.Use(hooks...)
	c.Product.Use(hooks...)
	c.Receipt.Use(hooks...)
	c.Title.Use(hooks...)
	c.Typeproduct.Use(hooks...)
}

// AdminrepairClient is a client for the Adminrepair schema.
type AdminrepairClient struct {
	config
}

// NewAdminrepairClient returns a client for the Adminrepair from the given config.
func NewAdminrepairClient(c config) *AdminrepairClient {
	return &AdminrepairClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adminrepair.Hooks(f(g(h())))`.
func (c *AdminrepairClient) Use(hooks ...Hook) {
	c.hooks.Adminrepair = append(c.hooks.Adminrepair, hooks...)
}

// Create returns a create builder for Adminrepair.
func (c *AdminrepairClient) Create() *AdminrepairCreate {
	mutation := newAdminrepairMutation(c.config, OpCreate)
	return &AdminrepairCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Adminrepair.
func (c *AdminrepairClient) Update() *AdminrepairUpdate {
	mutation := newAdminrepairMutation(c.config, OpUpdate)
	return &AdminrepairUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminrepairClient) UpdateOne(a *Adminrepair) *AdminrepairUpdateOne {
	mutation := newAdminrepairMutation(c.config, OpUpdateOne, withAdminrepair(a))
	return &AdminrepairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminrepairClient) UpdateOneID(id int) *AdminrepairUpdateOne {
	mutation := newAdminrepairMutation(c.config, OpUpdateOne, withAdminrepairID(id))
	return &AdminrepairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Adminrepair.
func (c *AdminrepairClient) Delete() *AdminrepairDelete {
	mutation := newAdminrepairMutation(c.config, OpDelete)
	return &AdminrepairDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AdminrepairClient) DeleteOne(a *Adminrepair) *AdminrepairDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AdminrepairClient) DeleteOneID(id int) *AdminrepairDeleteOne {
	builder := c.Delete().Where(adminrepair.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminrepairDeleteOne{builder}
}

// Create returns a query builder for Adminrepair.
func (c *AdminrepairClient) Query() *AdminrepairQuery {
	return &AdminrepairQuery{config: c.config}
}

// Get returns a Adminrepair entity by its id.
func (c *AdminrepairClient) Get(ctx context.Context, id int) (*Adminrepair, error) {
	return c.Query().Where(adminrepair.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminrepairClient) GetX(ctx context.Context, id int) *Adminrepair {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryReceipt queries the receipt edge of a Adminrepair.
func (c *AdminrepairClient) QueryReceipt(a *Adminrepair) *ReceiptQuery {
	query := &ReceiptQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adminrepair.Table, adminrepair.FieldID, id),
			sqlgraph.To(receipt.Table, receipt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, adminrepair.ReceiptTable, adminrepair.ReceiptColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdminrepairPersonal queries the AdminrepairPersonal edge of a Adminrepair.
func (c *AdminrepairClient) QueryAdminrepairPersonal(a *Adminrepair) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adminrepair.Table, adminrepair.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, adminrepair.AdminrepairPersonalTable, adminrepair.AdminrepairPersonalColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdminrepairFix queries the AdminrepairFix edge of a Adminrepair.
func (c *AdminrepairClient) QueryAdminrepairFix(a *Adminrepair) *FixQuery {
	query := &FixQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adminrepair.Table, adminrepair.FieldID, id),
			sqlgraph.To(fix.Table, fix.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, adminrepair.AdminrepairFixTable, adminrepair.AdminrepairFixColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdminrepairProduct queries the AdminrepairProduct edge of a Adminrepair.
func (c *AdminrepairClient) QueryAdminrepairProduct(a *Adminrepair) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adminrepair.Table, adminrepair.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, adminrepair.AdminrepairProductTable, adminrepair.AdminrepairProductColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AdminrepairClient) Hooks() []Hook {
	return c.hooks.Adminrepair
}

// BrandClient is a client for the Brand schema.
type BrandClient struct {
	config
}

// NewBrandClient returns a client for the Brand from the given config.
func NewBrandClient(c config) *BrandClient {
	return &BrandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `brand.Hooks(f(g(h())))`.
func (c *BrandClient) Use(hooks ...Hook) {
	c.hooks.Brand = append(c.hooks.Brand, hooks...)
}

// Create returns a create builder for Brand.
func (c *BrandClient) Create() *BrandCreate {
	mutation := newBrandMutation(c.config, OpCreate)
	return &BrandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Brand.
func (c *BrandClient) Update() *BrandUpdate {
	mutation := newBrandMutation(c.config, OpUpdate)
	return &BrandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BrandClient) UpdateOne(b *Brand) *BrandUpdateOne {
	mutation := newBrandMutation(c.config, OpUpdateOne, withBrand(b))
	return &BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BrandClient) UpdateOneID(id int) *BrandUpdateOne {
	mutation := newBrandMutation(c.config, OpUpdateOne, withBrandID(id))
	return &BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Brand.
func (c *BrandClient) Delete() *BrandDelete {
	mutation := newBrandMutation(c.config, OpDelete)
	return &BrandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BrandClient) DeleteOne(b *Brand) *BrandDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BrandClient) DeleteOneID(id int) *BrandDeleteOne {
	builder := c.Delete().Where(brand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BrandDeleteOne{builder}
}

// Create returns a query builder for Brand.
func (c *BrandClient) Query() *BrandQuery {
	return &BrandQuery{config: c.config}
}

// Get returns a Brand entity by its id.
func (c *BrandClient) Get(ctx context.Context, id int) (*Brand, error) {
	return c.Query().Where(brand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BrandClient) GetX(ctx context.Context, id int) *Brand {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// QueryProduct queries the product edge of a Brand.
func (c *BrandClient) QueryProduct(b *Brand) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(brand.Table, brand.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, brand.ProductTable, brand.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFix queries the fix edge of a Brand.
func (c *BrandClient) QueryFix(b *Brand) *FixQuery {
	query := &FixQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(brand.Table, brand.FieldID, id),
			sqlgraph.To(fix.Table, fix.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, brand.FixTable, brand.FixColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BrandClient) Hooks() []Hook {
	return c.hooks.Brand
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Create returns a create builder for Customer.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id int) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CustomerClient) DeleteOneID(id int) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Create returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{config: c.config}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id int) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id int) *Customer {
	cu, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return cu
}

// QueryGender queries the gender edge of a Customer.
func (c *CustomerClient) QueryGender(cu *Customer) *GenderQuery {
	query := &GenderQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(gender.Table, gender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.GenderTable, customer.GenderColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonal queries the personal edge of a Customer.
func (c *CustomerClient) QueryPersonal(cu *Customer) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.PersonalTable, customer.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTitle queries the title edge of a Customer.
func (c *CustomerClient) QueryTitle(cu *Customer) *TitleQuery {
	query := &TitleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(title.Table, title.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.TitleTable, customer.TitleColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFix queries the fix edge of a Customer.
func (c *CustomerClient) QueryFix(cu *Customer) *FixQuery {
	query := &FixQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(fix.Table, fix.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.FixTable, customer.FixColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	return c.hooks.Customer
}

// DepartmentClient is a client for the Department schema.
type DepartmentClient struct {
	config
}

// NewDepartmentClient returns a client for the Department from the given config.
func NewDepartmentClient(c config) *DepartmentClient {
	return &DepartmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `department.Hooks(f(g(h())))`.
func (c *DepartmentClient) Use(hooks ...Hook) {
	c.hooks.Department = append(c.hooks.Department, hooks...)
}

// Create returns a create builder for Department.
func (c *DepartmentClient) Create() *DepartmentCreate {
	mutation := newDepartmentMutation(c.config, OpCreate)
	return &DepartmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Department.
func (c *DepartmentClient) Update() *DepartmentUpdate {
	mutation := newDepartmentMutation(c.config, OpUpdate)
	return &DepartmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DepartmentClient) UpdateOne(d *Department) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartment(d))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DepartmentClient) UpdateOneID(id int) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartmentID(id))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Department.
func (c *DepartmentClient) Delete() *DepartmentDelete {
	mutation := newDepartmentMutation(c.config, OpDelete)
	return &DepartmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DepartmentClient) DeleteOne(d *Department) *DepartmentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DepartmentClient) DeleteOneID(id int) *DepartmentDeleteOne {
	builder := c.Delete().Where(department.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DepartmentDeleteOne{builder}
}

// Create returns a query builder for Department.
func (c *DepartmentClient) Query() *DepartmentQuery {
	return &DepartmentQuery{config: c.config}
}

// Get returns a Department entity by its id.
func (c *DepartmentClient) Get(ctx context.Context, id int) (*Department, error) {
	return c.Query().Where(department.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DepartmentClient) GetX(ctx context.Context, id int) *Department {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// QueryPersonal queries the personal edge of a Department.
func (c *DepartmentClient) QueryPersonal(d *Department) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, department.PersonalTable, department.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DepartmentClient) Hooks() []Hook {
	return c.hooks.Department
}

// FixClient is a client for the Fix schema.
type FixClient struct {
	config
}

// NewFixClient returns a client for the Fix from the given config.
func NewFixClient(c config) *FixClient {
	return &FixClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fix.Hooks(f(g(h())))`.
func (c *FixClient) Use(hooks ...Hook) {
	c.hooks.Fix = append(c.hooks.Fix, hooks...)
}

// Create returns a create builder for Fix.
func (c *FixClient) Create() *FixCreate {
	mutation := newFixMutation(c.config, OpCreate)
	return &FixCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Fix.
func (c *FixClient) Update() *FixUpdate {
	mutation := newFixMutation(c.config, OpUpdate)
	return &FixUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FixClient) UpdateOne(f *Fix) *FixUpdateOne {
	mutation := newFixMutation(c.config, OpUpdateOne, withFix(f))
	return &FixUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FixClient) UpdateOneID(id int) *FixUpdateOne {
	mutation := newFixMutation(c.config, OpUpdateOne, withFixID(id))
	return &FixUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fix.
func (c *FixClient) Delete() *FixDelete {
	mutation := newFixMutation(c.config, OpDelete)
	return &FixDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FixClient) DeleteOne(f *Fix) *FixDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FixClient) DeleteOneID(id int) *FixDeleteOne {
	builder := c.Delete().Where(fix.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FixDeleteOne{builder}
}

// Create returns a query builder for Fix.
func (c *FixClient) Query() *FixQuery {
	return &FixQuery{config: c.config}
}

// Get returns a Fix entity by its id.
func (c *FixClient) Get(ctx context.Context, id int) (*Fix, error) {
	return c.Query().Where(fix.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FixClient) GetX(ctx context.Context, id int) *Fix {
	f, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return f
}

// QueryFix queries the fix edge of a Fix.
func (c *FixClient) QueryFix(f *Fix) *AdminrepairQuery {
	query := &AdminrepairQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fix.Table, fix.FieldID, id),
			sqlgraph.To(adminrepair.Table, adminrepair.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, fix.FixTable, fix.FixColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBrand queries the brand edge of a Fix.
func (c *FixClient) QueryBrand(f *Fix) *BrandQuery {
	query := &BrandQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fix.Table, fix.FieldID, id),
			sqlgraph.To(brand.Table, brand.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fix.BrandTable, fix.BrandColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonal queries the personal edge of a Fix.
func (c *FixClient) QueryPersonal(f *Fix) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fix.Table, fix.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fix.PersonalTable, fix.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Fix.
func (c *FixClient) QueryCustomer(f *Fix) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fix.Table, fix.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fix.CustomerTable, fix.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixcomtype queries the fixcomtype edge of a Fix.
func (c *FixClient) QueryFixcomtype(f *Fix) *FixcomtypeQuery {
	query := &FixcomtypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fix.Table, fix.FieldID, id),
			sqlgraph.To(fixcomtype.Table, fixcomtype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fix.FixcomtypeTable, fix.FixcomtypeColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FixClient) Hooks() []Hook {
	return c.hooks.Fix
}

// FixcomtypeClient is a client for the Fixcomtype schema.
type FixcomtypeClient struct {
	config
}

// NewFixcomtypeClient returns a client for the Fixcomtype from the given config.
func NewFixcomtypeClient(c config) *FixcomtypeClient {
	return &FixcomtypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fixcomtype.Hooks(f(g(h())))`.
func (c *FixcomtypeClient) Use(hooks ...Hook) {
	c.hooks.Fixcomtype = append(c.hooks.Fixcomtype, hooks...)
}

// Create returns a create builder for Fixcomtype.
func (c *FixcomtypeClient) Create() *FixcomtypeCreate {
	mutation := newFixcomtypeMutation(c.config, OpCreate)
	return &FixcomtypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Fixcomtype.
func (c *FixcomtypeClient) Update() *FixcomtypeUpdate {
	mutation := newFixcomtypeMutation(c.config, OpUpdate)
	return &FixcomtypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FixcomtypeClient) UpdateOne(f *Fixcomtype) *FixcomtypeUpdateOne {
	mutation := newFixcomtypeMutation(c.config, OpUpdateOne, withFixcomtype(f))
	return &FixcomtypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FixcomtypeClient) UpdateOneID(id int) *FixcomtypeUpdateOne {
	mutation := newFixcomtypeMutation(c.config, OpUpdateOne, withFixcomtypeID(id))
	return &FixcomtypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fixcomtype.
func (c *FixcomtypeClient) Delete() *FixcomtypeDelete {
	mutation := newFixcomtypeMutation(c.config, OpDelete)
	return &FixcomtypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FixcomtypeClient) DeleteOne(f *Fixcomtype) *FixcomtypeDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FixcomtypeClient) DeleteOneID(id int) *FixcomtypeDeleteOne {
	builder := c.Delete().Where(fixcomtype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FixcomtypeDeleteOne{builder}
}

// Create returns a query builder for Fixcomtype.
func (c *FixcomtypeClient) Query() *FixcomtypeQuery {
	return &FixcomtypeQuery{config: c.config}
}

// Get returns a Fixcomtype entity by its id.
func (c *FixcomtypeClient) Get(ctx context.Context, id int) (*Fixcomtype, error) {
	return c.Query().Where(fixcomtype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FixcomtypeClient) GetX(ctx context.Context, id int) *Fixcomtype {
	f, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return f
}

// QueryFix queries the fix edge of a Fixcomtype.
func (c *FixcomtypeClient) QueryFix(f *Fixcomtype) *FixQuery {
	query := &FixQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixcomtype.Table, fixcomtype.FieldID, id),
			sqlgraph.To(fix.Table, fix.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, fixcomtype.FixTable, fixcomtype.FixColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FixcomtypeClient) Hooks() []Hook {
	return c.hooks.Fixcomtype
}

// GenderClient is a client for the Gender schema.
type GenderClient struct {
	config
}

// NewGenderClient returns a client for the Gender from the given config.
func NewGenderClient(c config) *GenderClient {
	return &GenderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gender.Hooks(f(g(h())))`.
func (c *GenderClient) Use(hooks ...Hook) {
	c.hooks.Gender = append(c.hooks.Gender, hooks...)
}

// Create returns a create builder for Gender.
func (c *GenderClient) Create() *GenderCreate {
	mutation := newGenderMutation(c.config, OpCreate)
	return &GenderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Gender.
func (c *GenderClient) Update() *GenderUpdate {
	mutation := newGenderMutation(c.config, OpUpdate)
	return &GenderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GenderClient) UpdateOne(ge *Gender) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGender(ge))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GenderClient) UpdateOneID(id int) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGenderID(id))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Gender.
func (c *GenderClient) Delete() *GenderDelete {
	mutation := newGenderMutation(c.config, OpDelete)
	return &GenderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GenderClient) DeleteOne(ge *Gender) *GenderDeleteOne {
	return c.DeleteOneID(ge.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GenderClient) DeleteOneID(id int) *GenderDeleteOne {
	builder := c.Delete().Where(gender.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GenderDeleteOne{builder}
}

// Create returns a query builder for Gender.
func (c *GenderClient) Query() *GenderQuery {
	return &GenderQuery{config: c.config}
}

// Get returns a Gender entity by its id.
func (c *GenderClient) Get(ctx context.Context, id int) (*Gender, error) {
	return c.Query().Where(gender.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GenderClient) GetX(ctx context.Context, id int) *Gender {
	ge, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ge
}

// QueryPersonal queries the personal edge of a Gender.
func (c *GenderClient) QueryPersonal(ge *Gender) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gender.Table, gender.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gender.PersonalTable, gender.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Gender.
func (c *GenderClient) QueryCustomer(ge *Gender) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gender.Table, gender.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gender.CustomerTable, gender.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GenderClient) Hooks() []Hook {
	return c.hooks.Gender
}

// PaymentTypeClient is a client for the PaymentType schema.
type PaymentTypeClient struct {
	config
}

// NewPaymentTypeClient returns a client for the PaymentType from the given config.
func NewPaymentTypeClient(c config) *PaymentTypeClient {
	return &PaymentTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paymenttype.Hooks(f(g(h())))`.
func (c *PaymentTypeClient) Use(hooks ...Hook) {
	c.hooks.PaymentType = append(c.hooks.PaymentType, hooks...)
}

// Create returns a create builder for PaymentType.
func (c *PaymentTypeClient) Create() *PaymentTypeCreate {
	mutation := newPaymentTypeMutation(c.config, OpCreate)
	return &PaymentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for PaymentType.
func (c *PaymentTypeClient) Update() *PaymentTypeUpdate {
	mutation := newPaymentTypeMutation(c.config, OpUpdate)
	return &PaymentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentTypeClient) UpdateOne(pt *PaymentType) *PaymentTypeUpdateOne {
	mutation := newPaymentTypeMutation(c.config, OpUpdateOne, withPaymentType(pt))
	return &PaymentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentTypeClient) UpdateOneID(id int) *PaymentTypeUpdateOne {
	mutation := newPaymentTypeMutation(c.config, OpUpdateOne, withPaymentTypeID(id))
	return &PaymentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaymentType.
func (c *PaymentTypeClient) Delete() *PaymentTypeDelete {
	mutation := newPaymentTypeMutation(c.config, OpDelete)
	return &PaymentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PaymentTypeClient) DeleteOne(pt *PaymentType) *PaymentTypeDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PaymentTypeClient) DeleteOneID(id int) *PaymentTypeDeleteOne {
	builder := c.Delete().Where(paymenttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentTypeDeleteOne{builder}
}

// Create returns a query builder for PaymentType.
func (c *PaymentTypeClient) Query() *PaymentTypeQuery {
	return &PaymentTypeQuery{config: c.config}
}

// Get returns a PaymentType entity by its id.
func (c *PaymentTypeClient) Get(ctx context.Context, id int) (*PaymentType, error) {
	return c.Query().Where(paymenttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentTypeClient) GetX(ctx context.Context, id int) *PaymentType {
	pt, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pt
}

// QueryReceipt queries the receipt edge of a PaymentType.
func (c *PaymentTypeClient) QueryReceipt(pt *PaymentType) *ReceiptQuery {
	query := &ReceiptQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(paymenttype.Table, paymenttype.FieldID, id),
			sqlgraph.To(receipt.Table, receipt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, paymenttype.ReceiptTable, paymenttype.ReceiptColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PaymentTypeClient) Hooks() []Hook {
	return c.hooks.PaymentType
}

// PersonalClient is a client for the Personal schema.
type PersonalClient struct {
	config
}

// NewPersonalClient returns a client for the Personal from the given config.
func NewPersonalClient(c config) *PersonalClient {
	return &PersonalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personal.Hooks(f(g(h())))`.
func (c *PersonalClient) Use(hooks ...Hook) {
	c.hooks.Personal = append(c.hooks.Personal, hooks...)
}

// Create returns a create builder for Personal.
func (c *PersonalClient) Create() *PersonalCreate {
	mutation := newPersonalMutation(c.config, OpCreate)
	return &PersonalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Personal.
func (c *PersonalClient) Update() *PersonalUpdate {
	mutation := newPersonalMutation(c.config, OpUpdate)
	return &PersonalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonalClient) UpdateOne(pe *Personal) *PersonalUpdateOne {
	mutation := newPersonalMutation(c.config, OpUpdateOne, withPersonal(pe))
	return &PersonalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonalClient) UpdateOneID(id int) *PersonalUpdateOne {
	mutation := newPersonalMutation(c.config, OpUpdateOne, withPersonalID(id))
	return &PersonalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Personal.
func (c *PersonalClient) Delete() *PersonalDelete {
	mutation := newPersonalMutation(c.config, OpDelete)
	return &PersonalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PersonalClient) DeleteOne(pe *Personal) *PersonalDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PersonalClient) DeleteOneID(id int) *PersonalDeleteOne {
	builder := c.Delete().Where(personal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonalDeleteOne{builder}
}

// Create returns a query builder for Personal.
func (c *PersonalClient) Query() *PersonalQuery {
	return &PersonalQuery{config: c.config}
}

// Get returns a Personal entity by its id.
func (c *PersonalClient) Get(ctx context.Context, id int) (*Personal, error) {
	return c.Query().Where(personal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonalClient) GetX(ctx context.Context, id int) *Personal {
	pe, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pe
}

// QueryCustomer queries the customer edge of a Personal.
func (c *PersonalClient) QueryCustomer(pe *Personal) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, personal.CustomerTable, personal.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTitle queries the title edge of a Personal.
func (c *PersonalClient) QueryTitle(pe *Personal) *TitleQuery {
	query := &TitleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(title.Table, title.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personal.TitleTable, personal.TitleColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartment queries the department edge of a Personal.
func (c *PersonalClient) QueryDepartment(pe *Personal) *DepartmentQuery {
	query := &DepartmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personal.DepartmentTable, personal.DepartmentColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGender queries the gender edge of a Personal.
func (c *PersonalClient) QueryGender(pe *Personal) *GenderQuery {
	query := &GenderQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(gender.Table, gender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personal.GenderTable, personal.GenderColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a Personal.
func (c *PersonalClient) QueryProduct(pe *Personal) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, personal.ProductTable, personal.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFix queries the fix edge of a Personal.
func (c *PersonalClient) QueryFix(pe *Personal) *FixQuery {
	query := &FixQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(fix.Table, fix.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, personal.FixTable, personal.FixColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonal queries the personal edge of a Personal.
func (c *PersonalClient) QueryPersonal(pe *Personal) *AdminrepairQuery {
	query := &AdminrepairQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(adminrepair.Table, adminrepair.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, personal.PersonalTable, personal.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceipt queries the receipt edge of a Personal.
func (c *PersonalClient) QueryReceipt(pe *Personal) *ReceiptQuery {
	query := &ReceiptQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(receipt.Table, receipt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, personal.ReceiptTable, personal.ReceiptColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonalClient) Hooks() []Hook {
	return c.hooks.Personal
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Create returns a create builder for Product.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProductClient) DeleteOneID(id int) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Create returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{config: c.config}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int) *Product {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// QueryProduct queries the product edge of a Product.
func (c *ProductClient) QueryProduct(pr *Product) *AdminrepairQuery {
	query := &AdminrepairQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(adminrepair.Table, adminrepair.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.ProductTable, product.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBrand queries the brand edge of a Product.
func (c *ProductClient) QueryBrand(pr *Product) *BrandQuery {
	query := &BrandQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(brand.Table, brand.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.BrandTable, product.BrandColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTypeproduct queries the typeproduct edge of a Product.
func (c *ProductClient) QueryTypeproduct(pr *Product) *TypeproductQuery {
	query := &TypeproductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(typeproduct.Table, typeproduct.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.TypeproductTable, product.TypeproductColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonal queries the personal edge of a Product.
func (c *ProductClient) QueryPersonal(pr *Product) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.PersonalTable, product.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// ReceiptClient is a client for the Receipt schema.
type ReceiptClient struct {
	config
}

// NewReceiptClient returns a client for the Receipt from the given config.
func NewReceiptClient(c config) *ReceiptClient {
	return &ReceiptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `receipt.Hooks(f(g(h())))`.
func (c *ReceiptClient) Use(hooks ...Hook) {
	c.hooks.Receipt = append(c.hooks.Receipt, hooks...)
}

// Create returns a create builder for Receipt.
func (c *ReceiptClient) Create() *ReceiptCreate {
	mutation := newReceiptMutation(c.config, OpCreate)
	return &ReceiptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Receipt.
func (c *ReceiptClient) Update() *ReceiptUpdate {
	mutation := newReceiptMutation(c.config, OpUpdate)
	return &ReceiptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReceiptClient) UpdateOne(r *Receipt) *ReceiptUpdateOne {
	mutation := newReceiptMutation(c.config, OpUpdateOne, withReceipt(r))
	return &ReceiptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReceiptClient) UpdateOneID(id int) *ReceiptUpdateOne {
	mutation := newReceiptMutation(c.config, OpUpdateOne, withReceiptID(id))
	return &ReceiptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Receipt.
func (c *ReceiptClient) Delete() *ReceiptDelete {
	mutation := newReceiptMutation(c.config, OpDelete)
	return &ReceiptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReceiptClient) DeleteOne(r *Receipt) *ReceiptDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReceiptClient) DeleteOneID(id int) *ReceiptDeleteOne {
	builder := c.Delete().Where(receipt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReceiptDeleteOne{builder}
}

// Create returns a query builder for Receipt.
func (c *ReceiptClient) Query() *ReceiptQuery {
	return &ReceiptQuery{config: c.config}
}

// Get returns a Receipt entity by its id.
func (c *ReceiptClient) Get(ctx context.Context, id int) (*Receipt, error) {
	return c.Query().Where(receipt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReceiptClient) GetX(ctx context.Context, id int) *Receipt {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryPaymenttype queries the paymenttype edge of a Receipt.
func (c *ReceiptClient) QueryPaymenttype(r *Receipt) *PaymentTypeQuery {
	query := &PaymentTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(receipt.Table, receipt.FieldID, id),
			sqlgraph.To(paymenttype.Table, paymenttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, receipt.PaymenttypeTable, receipt.PaymenttypeColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdminrepair queries the adminrepair edge of a Receipt.
func (c *ReceiptClient) QueryAdminrepair(r *Receipt) *AdminrepairQuery {
	query := &AdminrepairQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(receipt.Table, receipt.FieldID, id),
			sqlgraph.To(adminrepair.Table, adminrepair.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, receipt.AdminrepairTable, receipt.AdminrepairColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonal queries the personal edge of a Receipt.
func (c *ReceiptClient) QueryPersonal(r *Receipt) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(receipt.Table, receipt.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, receipt.PersonalTable, receipt.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReceiptClient) Hooks() []Hook {
	return c.hooks.Receipt
}

// TitleClient is a client for the Title schema.
type TitleClient struct {
	config
}

// NewTitleClient returns a client for the Title from the given config.
func NewTitleClient(c config) *TitleClient {
	return &TitleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `title.Hooks(f(g(h())))`.
func (c *TitleClient) Use(hooks ...Hook) {
	c.hooks.Title = append(c.hooks.Title, hooks...)
}

// Create returns a create builder for Title.
func (c *TitleClient) Create() *TitleCreate {
	mutation := newTitleMutation(c.config, OpCreate)
	return &TitleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Title.
func (c *TitleClient) Update() *TitleUpdate {
	mutation := newTitleMutation(c.config, OpUpdate)
	return &TitleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TitleClient) UpdateOne(t *Title) *TitleUpdateOne {
	mutation := newTitleMutation(c.config, OpUpdateOne, withTitle(t))
	return &TitleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TitleClient) UpdateOneID(id int) *TitleUpdateOne {
	mutation := newTitleMutation(c.config, OpUpdateOne, withTitleID(id))
	return &TitleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Title.
func (c *TitleClient) Delete() *TitleDelete {
	mutation := newTitleMutation(c.config, OpDelete)
	return &TitleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TitleClient) DeleteOne(t *Title) *TitleDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TitleClient) DeleteOneID(id int) *TitleDeleteOne {
	builder := c.Delete().Where(title.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TitleDeleteOne{builder}
}

// Create returns a query builder for Title.
func (c *TitleClient) Query() *TitleQuery {
	return &TitleQuery{config: c.config}
}

// Get returns a Title entity by its id.
func (c *TitleClient) Get(ctx context.Context, id int) (*Title, error) {
	return c.Query().Where(title.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TitleClient) GetX(ctx context.Context, id int) *Title {
	t, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return t
}

// QueryPersonal queries the personal edge of a Title.
func (c *TitleClient) QueryPersonal(t *Title) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(title.Table, title.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, title.PersonalTable, title.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Title.
func (c *TitleClient) QueryCustomer(t *Title) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(title.Table, title.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, title.CustomerTable, title.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TitleClient) Hooks() []Hook {
	return c.hooks.Title
}

// TypeproductClient is a client for the Typeproduct schema.
type TypeproductClient struct {
	config
}

// NewTypeproductClient returns a client for the Typeproduct from the given config.
func NewTypeproductClient(c config) *TypeproductClient {
	return &TypeproductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `typeproduct.Hooks(f(g(h())))`.
func (c *TypeproductClient) Use(hooks ...Hook) {
	c.hooks.Typeproduct = append(c.hooks.Typeproduct, hooks...)
}

// Create returns a create builder for Typeproduct.
func (c *TypeproductClient) Create() *TypeproductCreate {
	mutation := newTypeproductMutation(c.config, OpCreate)
	return &TypeproductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Typeproduct.
func (c *TypeproductClient) Update() *TypeproductUpdate {
	mutation := newTypeproductMutation(c.config, OpUpdate)
	return &TypeproductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TypeproductClient) UpdateOne(t *Typeproduct) *TypeproductUpdateOne {
	mutation := newTypeproductMutation(c.config, OpUpdateOne, withTypeproduct(t))
	return &TypeproductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TypeproductClient) UpdateOneID(id int) *TypeproductUpdateOne {
	mutation := newTypeproductMutation(c.config, OpUpdateOne, withTypeproductID(id))
	return &TypeproductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Typeproduct.
func (c *TypeproductClient) Delete() *TypeproductDelete {
	mutation := newTypeproductMutation(c.config, OpDelete)
	return &TypeproductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TypeproductClient) DeleteOne(t *Typeproduct) *TypeproductDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TypeproductClient) DeleteOneID(id int) *TypeproductDeleteOne {
	builder := c.Delete().Where(typeproduct.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TypeproductDeleteOne{builder}
}

// Create returns a query builder for Typeproduct.
func (c *TypeproductClient) Query() *TypeproductQuery {
	return &TypeproductQuery{config: c.config}
}

// Get returns a Typeproduct entity by its id.
func (c *TypeproductClient) Get(ctx context.Context, id int) (*Typeproduct, error) {
	return c.Query().Where(typeproduct.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TypeproductClient) GetX(ctx context.Context, id int) *Typeproduct {
	t, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return t
}

// QueryProduct queries the product edge of a Typeproduct.
func (c *TypeproductClient) QueryProduct(t *Typeproduct) *ProductQuery {
	query := &ProductQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(typeproduct.Table, typeproduct.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, typeproduct.ProductTable, typeproduct.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TypeproductClient) Hooks() []Hook {
	return c.hooks.Typeproduct
}
