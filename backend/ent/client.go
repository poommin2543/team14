// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/tanapon395/playlist-video/ent/migrate"

	"github.com/tanapon395/playlist-video/ent/adminrepair"
	"github.com/tanapon395/playlist-video/ent/customer"
	"github.com/tanapon395/playlist-video/ent/department"
	"github.com/tanapon395/playlist-video/ent/fix"
	"github.com/tanapon395/playlist-video/ent/gender"
	"github.com/tanapon395/playlist-video/ent/personal"
	"github.com/tanapon395/playlist-video/ent/product"
	"github.com/tanapon395/playlist-video/ent/receipt"
	"github.com/tanapon395/playlist-video/ent/title"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Adminrepair is the client for interacting with the Adminrepair builders.
	Adminrepair *AdminrepairClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// Department is the client for interacting with the Department builders.
	Department *DepartmentClient
	// Fix is the client for interacting with the Fix builders.
	Fix *FixClient
	// Gender is the client for interacting with the Gender builders.
	Gender *GenderClient
	// Personal is the client for interacting with the Personal builders.
	Personal *PersonalClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// Receipt is the client for interacting with the Receipt builders.
	Receipt *ReceiptClient
	// Title is the client for interacting with the Title builders.
	Title *TitleClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Adminrepair = NewAdminrepairClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.Department = NewDepartmentClient(c.config)
	c.Fix = NewFixClient(c.config)
	c.Gender = NewGenderClient(c.config)
	c.Personal = NewPersonalClient(c.config)
	c.Product = NewProductClient(c.config)
	c.Receipt = NewReceiptClient(c.config)
	c.Title = NewTitleClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Adminrepair: NewAdminrepairClient(cfg),
		Customer:    NewCustomerClient(cfg),
		Department:  NewDepartmentClient(cfg),
		Fix:         NewFixClient(cfg),
		Gender:      NewGenderClient(cfg),
		Personal:    NewPersonalClient(cfg),
		Product:     NewProductClient(cfg),
		Receipt:     NewReceiptClient(cfg),
		Title:       NewTitleClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:      cfg,
		Adminrepair: NewAdminrepairClient(cfg),
		Customer:    NewCustomerClient(cfg),
		Department:  NewDepartmentClient(cfg),
		Fix:         NewFixClient(cfg),
		Gender:      NewGenderClient(cfg),
		Personal:    NewPersonalClient(cfg),
		Product:     NewProductClient(cfg),
		Receipt:     NewReceiptClient(cfg),
		Title:       NewTitleClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Adminrepair.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Adminrepair.Use(hooks...)
	c.Customer.Use(hooks...)
	c.Department.Use(hooks...)
	c.Fix.Use(hooks...)
	c.Gender.Use(hooks...)
	c.Personal.Use(hooks...)
	c.Product.Use(hooks...)
	c.Receipt.Use(hooks...)
	c.Title.Use(hooks...)
}

// AdminrepairClient is a client for the Adminrepair schema.
type AdminrepairClient struct {
	config
}

// NewAdminrepairClient returns a client for the Adminrepair from the given config.
func NewAdminrepairClient(c config) *AdminrepairClient {
	return &AdminrepairClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adminrepair.Hooks(f(g(h())))`.
func (c *AdminrepairClient) Use(hooks ...Hook) {
	c.hooks.Adminrepair = append(c.hooks.Adminrepair, hooks...)
}

// Create returns a create builder for Adminrepair.
func (c *AdminrepairClient) Create() *AdminrepairCreate {
	mutation := newAdminrepairMutation(c.config, OpCreate)
	return &AdminrepairCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Adminrepair.
func (c *AdminrepairClient) Update() *AdminrepairUpdate {
	mutation := newAdminrepairMutation(c.config, OpUpdate)
	return &AdminrepairUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminrepairClient) UpdateOne(a *Adminrepair) *AdminrepairUpdateOne {
	mutation := newAdminrepairMutation(c.config, OpUpdateOne, withAdminrepair(a))
	return &AdminrepairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminrepairClient) UpdateOneID(id int) *AdminrepairUpdateOne {
	mutation := newAdminrepairMutation(c.config, OpUpdateOne, withAdminrepairID(id))
	return &AdminrepairUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Adminrepair.
func (c *AdminrepairClient) Delete() *AdminrepairDelete {
	mutation := newAdminrepairMutation(c.config, OpDelete)
	return &AdminrepairDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AdminrepairClient) DeleteOne(a *Adminrepair) *AdminrepairDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AdminrepairClient) DeleteOneID(id int) *AdminrepairDeleteOne {
	builder := c.Delete().Where(adminrepair.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminrepairDeleteOne{builder}
}

// Create returns a query builder for Adminrepair.
func (c *AdminrepairClient) Query() *AdminrepairQuery {
	return &AdminrepairQuery{config: c.config}
}

// Get returns a Adminrepair entity by its id.
func (c *AdminrepairClient) Get(ctx context.Context, id int) (*Adminrepair, error) {
	return c.Query().Where(adminrepair.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminrepairClient) GetX(ctx context.Context, id int) *Adminrepair {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// Hooks returns the client hooks.
func (c *AdminrepairClient) Hooks() []Hook {
	return c.hooks.Adminrepair
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Create returns a create builder for Customer.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id int) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CustomerClient) DeleteOneID(id int) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Create returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{config: c.config}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id int) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id int) *Customer {
	cu, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return cu
}

// QueryGender queries the gender edge of a Customer.
func (c *CustomerClient) QueryGender(cu *Customer) *GenderQuery {
	query := &GenderQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(gender.Table, gender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.GenderTable, customer.GenderColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonal queries the personal edge of a Customer.
func (c *CustomerClient) QueryPersonal(cu *Customer) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.PersonalTable, customer.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTitle queries the title edge of a Customer.
func (c *CustomerClient) QueryTitle(cu *Customer) *TitleQuery {
	query := &TitleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(title.Table, title.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.TitleTable, customer.TitleColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	return c.hooks.Customer
}

// DepartmentClient is a client for the Department schema.
type DepartmentClient struct {
	config
}

// NewDepartmentClient returns a client for the Department from the given config.
func NewDepartmentClient(c config) *DepartmentClient {
	return &DepartmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `department.Hooks(f(g(h())))`.
func (c *DepartmentClient) Use(hooks ...Hook) {
	c.hooks.Department = append(c.hooks.Department, hooks...)
}

// Create returns a create builder for Department.
func (c *DepartmentClient) Create() *DepartmentCreate {
	mutation := newDepartmentMutation(c.config, OpCreate)
	return &DepartmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Department.
func (c *DepartmentClient) Update() *DepartmentUpdate {
	mutation := newDepartmentMutation(c.config, OpUpdate)
	return &DepartmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DepartmentClient) UpdateOne(d *Department) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartment(d))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DepartmentClient) UpdateOneID(id int) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartmentID(id))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Department.
func (c *DepartmentClient) Delete() *DepartmentDelete {
	mutation := newDepartmentMutation(c.config, OpDelete)
	return &DepartmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DepartmentClient) DeleteOne(d *Department) *DepartmentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DepartmentClient) DeleteOneID(id int) *DepartmentDeleteOne {
	builder := c.Delete().Where(department.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DepartmentDeleteOne{builder}
}

// Create returns a query builder for Department.
func (c *DepartmentClient) Query() *DepartmentQuery {
	return &DepartmentQuery{config: c.config}
}

// Get returns a Department entity by its id.
func (c *DepartmentClient) Get(ctx context.Context, id int) (*Department, error) {
	return c.Query().Where(department.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DepartmentClient) GetX(ctx context.Context, id int) *Department {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// QueryPersonal queries the personal edge of a Department.
func (c *DepartmentClient) QueryPersonal(d *Department) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, department.PersonalTable, department.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Department.
func (c *DepartmentClient) QueryCustomer(d *Department) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, department.CustomerTable, department.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DepartmentClient) Hooks() []Hook {
	return c.hooks.Department
}

// FixClient is a client for the Fix schema.
type FixClient struct {
	config
}

// NewFixClient returns a client for the Fix from the given config.
func NewFixClient(c config) *FixClient {
	return &FixClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fix.Hooks(f(g(h())))`.
func (c *FixClient) Use(hooks ...Hook) {
	c.hooks.Fix = append(c.hooks.Fix, hooks...)
}

// Create returns a create builder for Fix.
func (c *FixClient) Create() *FixCreate {
	mutation := newFixMutation(c.config, OpCreate)
	return &FixCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Fix.
func (c *FixClient) Update() *FixUpdate {
	mutation := newFixMutation(c.config, OpUpdate)
	return &FixUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FixClient) UpdateOne(f *Fix) *FixUpdateOne {
	mutation := newFixMutation(c.config, OpUpdateOne, withFix(f))
	return &FixUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FixClient) UpdateOneID(id int) *FixUpdateOne {
	mutation := newFixMutation(c.config, OpUpdateOne, withFixID(id))
	return &FixUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fix.
func (c *FixClient) Delete() *FixDelete {
	mutation := newFixMutation(c.config, OpDelete)
	return &FixDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FixClient) DeleteOne(f *Fix) *FixDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FixClient) DeleteOneID(id int) *FixDeleteOne {
	builder := c.Delete().Where(fix.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FixDeleteOne{builder}
}

// Create returns a query builder for Fix.
func (c *FixClient) Query() *FixQuery {
	return &FixQuery{config: c.config}
}

// Get returns a Fix entity by its id.
func (c *FixClient) Get(ctx context.Context, id int) (*Fix, error) {
	return c.Query().Where(fix.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FixClient) GetX(ctx context.Context, id int) *Fix {
	f, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return f
}

// Hooks returns the client hooks.
func (c *FixClient) Hooks() []Hook {
	return c.hooks.Fix
}

// GenderClient is a client for the Gender schema.
type GenderClient struct {
	config
}

// NewGenderClient returns a client for the Gender from the given config.
func NewGenderClient(c config) *GenderClient {
	return &GenderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gender.Hooks(f(g(h())))`.
func (c *GenderClient) Use(hooks ...Hook) {
	c.hooks.Gender = append(c.hooks.Gender, hooks...)
}

// Create returns a create builder for Gender.
func (c *GenderClient) Create() *GenderCreate {
	mutation := newGenderMutation(c.config, OpCreate)
	return &GenderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Gender.
func (c *GenderClient) Update() *GenderUpdate {
	mutation := newGenderMutation(c.config, OpUpdate)
	return &GenderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GenderClient) UpdateOne(ge *Gender) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGender(ge))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GenderClient) UpdateOneID(id int) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGenderID(id))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Gender.
func (c *GenderClient) Delete() *GenderDelete {
	mutation := newGenderMutation(c.config, OpDelete)
	return &GenderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GenderClient) DeleteOne(ge *Gender) *GenderDeleteOne {
	return c.DeleteOneID(ge.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GenderClient) DeleteOneID(id int) *GenderDeleteOne {
	builder := c.Delete().Where(gender.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GenderDeleteOne{builder}
}

// Create returns a query builder for Gender.
func (c *GenderClient) Query() *GenderQuery {
	return &GenderQuery{config: c.config}
}

// Get returns a Gender entity by its id.
func (c *GenderClient) Get(ctx context.Context, id int) (*Gender, error) {
	return c.Query().Where(gender.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GenderClient) GetX(ctx context.Context, id int) *Gender {
	ge, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ge
}

// QueryPersonal queries the personal edge of a Gender.
func (c *GenderClient) QueryPersonal(ge *Gender) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gender.Table, gender.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gender.PersonalTable, gender.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Gender.
func (c *GenderClient) QueryCustomer(ge *Gender) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gender.Table, gender.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gender.CustomerTable, gender.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GenderClient) Hooks() []Hook {
	return c.hooks.Gender
}

// PersonalClient is a client for the Personal schema.
type PersonalClient struct {
	config
}

// NewPersonalClient returns a client for the Personal from the given config.
func NewPersonalClient(c config) *PersonalClient {
	return &PersonalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personal.Hooks(f(g(h())))`.
func (c *PersonalClient) Use(hooks ...Hook) {
	c.hooks.Personal = append(c.hooks.Personal, hooks...)
}

// Create returns a create builder for Personal.
func (c *PersonalClient) Create() *PersonalCreate {
	mutation := newPersonalMutation(c.config, OpCreate)
	return &PersonalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Personal.
func (c *PersonalClient) Update() *PersonalUpdate {
	mutation := newPersonalMutation(c.config, OpUpdate)
	return &PersonalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonalClient) UpdateOne(pe *Personal) *PersonalUpdateOne {
	mutation := newPersonalMutation(c.config, OpUpdateOne, withPersonal(pe))
	return &PersonalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonalClient) UpdateOneID(id int) *PersonalUpdateOne {
	mutation := newPersonalMutation(c.config, OpUpdateOne, withPersonalID(id))
	return &PersonalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Personal.
func (c *PersonalClient) Delete() *PersonalDelete {
	mutation := newPersonalMutation(c.config, OpDelete)
	return &PersonalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PersonalClient) DeleteOne(pe *Personal) *PersonalDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PersonalClient) DeleteOneID(id int) *PersonalDeleteOne {
	builder := c.Delete().Where(personal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonalDeleteOne{builder}
}

// Create returns a query builder for Personal.
func (c *PersonalClient) Query() *PersonalQuery {
	return &PersonalQuery{config: c.config}
}

// Get returns a Personal entity by its id.
func (c *PersonalClient) Get(ctx context.Context, id int) (*Personal, error) {
	return c.Query().Where(personal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonalClient) GetX(ctx context.Context, id int) *Personal {
	pe, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pe
}

// QueryCustomer queries the customer edge of a Personal.
func (c *PersonalClient) QueryCustomer(pe *Personal) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, personal.CustomerTable, personal.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTitle queries the title edge of a Personal.
func (c *PersonalClient) QueryTitle(pe *Personal) *TitleQuery {
	query := &TitleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(title.Table, title.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personal.TitleTable, personal.TitleColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartment queries the department edge of a Personal.
func (c *PersonalClient) QueryDepartment(pe *Personal) *DepartmentQuery {
	query := &DepartmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personal.DepartmentTable, personal.DepartmentColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGender queries the gender edge of a Personal.
func (c *PersonalClient) QueryGender(pe *Personal) *GenderQuery {
	query := &GenderQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(gender.Table, gender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personal.GenderTable, personal.GenderColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonalClient) Hooks() []Hook {
	return c.hooks.Personal
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Create returns a create builder for Product.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProductClient) DeleteOneID(id int) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Create returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{config: c.config}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int) *Product {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// ReceiptClient is a client for the Receipt schema.
type ReceiptClient struct {
	config
}

// NewReceiptClient returns a client for the Receipt from the given config.
func NewReceiptClient(c config) *ReceiptClient {
	return &ReceiptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `receipt.Hooks(f(g(h())))`.
func (c *ReceiptClient) Use(hooks ...Hook) {
	c.hooks.Receipt = append(c.hooks.Receipt, hooks...)
}

// Create returns a create builder for Receipt.
func (c *ReceiptClient) Create() *ReceiptCreate {
	mutation := newReceiptMutation(c.config, OpCreate)
	return &ReceiptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Receipt.
func (c *ReceiptClient) Update() *ReceiptUpdate {
	mutation := newReceiptMutation(c.config, OpUpdate)
	return &ReceiptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReceiptClient) UpdateOne(r *Receipt) *ReceiptUpdateOne {
	mutation := newReceiptMutation(c.config, OpUpdateOne, withReceipt(r))
	return &ReceiptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReceiptClient) UpdateOneID(id int) *ReceiptUpdateOne {
	mutation := newReceiptMutation(c.config, OpUpdateOne, withReceiptID(id))
	return &ReceiptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Receipt.
func (c *ReceiptClient) Delete() *ReceiptDelete {
	mutation := newReceiptMutation(c.config, OpDelete)
	return &ReceiptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReceiptClient) DeleteOne(r *Receipt) *ReceiptDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReceiptClient) DeleteOneID(id int) *ReceiptDeleteOne {
	builder := c.Delete().Where(receipt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReceiptDeleteOne{builder}
}

// Create returns a query builder for Receipt.
func (c *ReceiptClient) Query() *ReceiptQuery {
	return &ReceiptQuery{config: c.config}
}

// Get returns a Receipt entity by its id.
func (c *ReceiptClient) Get(ctx context.Context, id int) (*Receipt, error) {
	return c.Query().Where(receipt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReceiptClient) GetX(ctx context.Context, id int) *Receipt {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// Hooks returns the client hooks.
func (c *ReceiptClient) Hooks() []Hook {
	return c.hooks.Receipt
}

// TitleClient is a client for the Title schema.
type TitleClient struct {
	config
}

// NewTitleClient returns a client for the Title from the given config.
func NewTitleClient(c config) *TitleClient {
	return &TitleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `title.Hooks(f(g(h())))`.
func (c *TitleClient) Use(hooks ...Hook) {
	c.hooks.Title = append(c.hooks.Title, hooks...)
}

// Create returns a create builder for Title.
func (c *TitleClient) Create() *TitleCreate {
	mutation := newTitleMutation(c.config, OpCreate)
	return &TitleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Title.
func (c *TitleClient) Update() *TitleUpdate {
	mutation := newTitleMutation(c.config, OpUpdate)
	return &TitleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TitleClient) UpdateOne(t *Title) *TitleUpdateOne {
	mutation := newTitleMutation(c.config, OpUpdateOne, withTitle(t))
	return &TitleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TitleClient) UpdateOneID(id int) *TitleUpdateOne {
	mutation := newTitleMutation(c.config, OpUpdateOne, withTitleID(id))
	return &TitleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Title.
func (c *TitleClient) Delete() *TitleDelete {
	mutation := newTitleMutation(c.config, OpDelete)
	return &TitleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TitleClient) DeleteOne(t *Title) *TitleDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TitleClient) DeleteOneID(id int) *TitleDeleteOne {
	builder := c.Delete().Where(title.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TitleDeleteOne{builder}
}

// Create returns a query builder for Title.
func (c *TitleClient) Query() *TitleQuery {
	return &TitleQuery{config: c.config}
}

// Get returns a Title entity by its id.
func (c *TitleClient) Get(ctx context.Context, id int) (*Title, error) {
	return c.Query().Where(title.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TitleClient) GetX(ctx context.Context, id int) *Title {
	t, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return t
}

// QueryPersonal queries the personal edge of a Title.
func (c *TitleClient) QueryPersonal(t *Title) *PersonalQuery {
	query := &PersonalQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(title.Table, title.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, title.PersonalTable, title.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Title.
func (c *TitleClient) QueryCustomer(t *Title) *CustomerQuery {
	query := &CustomerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(title.Table, title.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, title.CustomerTable, title.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TitleClient) Hooks() []Hook {
	return c.hooks.Title
}
